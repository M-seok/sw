import os
import sys
import json
import time
import asyncio
import logging
import threading
import hashlib
import requests
import numpy as np
import pandas as pd
import tensorflow as tf
from datetime import datetime, timedelta
from concurrent.futures import ThreadPoolExecutor
from tenacity import retry, stop_after_attempt, wait_exponential
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout, Input
from dotenv import load_dotenv
import pyupbit
from openai import OpenAI
import ta
import telegram
from telegram import Bot
from filelock import FileLock

# API í‚¤ ì„¤ì •
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
UPBIT_ACCESS_KEY = os.getenv("UPBIT_ACCESS_KEY")
UPBIT_SECRET_KEY = os.getenv("UPBIT_SECRET_KEY")

async def find_trading_opportunities(self):
        self.opportunities = await self.market_analyzer.scan_for_opportunities()
        logger.info(f"{len(self.opportunities)}ê°œì˜ ê±°ë˜ ê¸°íšŒ ë°œê²¬")

    async def dollar_cost_averaging(self, ticker):
        try:
            position = self.stop_loss_manager.positions.get(ticker)
            if not position:
                logger.warning(f"{ticker} í¬ì§€ì…˜ì´ ì—†ì–´ DCA ì‹¤í–‰ ë¶ˆê°€")
                return False

            current_price = pyupbit.get_current_price(ticker)
            if not current_price:
                logger.error(f"{ticker} í˜„ì¬ ê°€ê²© ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨")
                return False

            profit_percent = ((current_price - position['entry_price']) / position['entry_price']) * 100
            if profit_percent > -3:
                logger.info(f"{ticker} ì†ì‹¤ë¥  {profit_percent:.2f}%ë¡œ DCA ì¡°ê±´ ë¯¸ì¶©ì¡±")
                return False

            krw_balance = upbit.get_balance("KRW")
            if krw_balance is None or krw_balance < MIN_KRW_BALANCE:
                logger.info(f"KRW ì”ê³  ë¶€ì¡±: {krw_balance if krw_balance else 'ì—†ìŒ'}ì›")
                return False

            budget = krw_balance * self.dca_ratio
            amount = budget / current_price

            logger.info(f"{ticker} í‰ë‹¨ í•˜í–¥ ë§¤ìˆ˜ ì‹œë„: ì˜ˆì‚°={budget:,.0f}ì›, í˜„ì¬ê°€={current_price:,.2f}ì›")
            buy_order = upbit.buy_market_order(ticker, budget)

            if buy_order and "uuid" in buy_order:
                order_uuid = buy_order["uuid"]
                order_info = upbit.get_order(order_uuid)
                for _ in range(10):
                    if order_info and order_info["state"] in ["done", "cancel"]:
                        break
                    await asyncio.sleep(1)
                    order_info = upbit.get_order(order_uuid)

                executed_amount = float(order_info.get("executed_volume", 0)) if order_info else 0
                if executed_amount > 0:
                    executed_price = current_price
                    reason = f"DCA: ì†ì‹¤ë¥  {profit_percent:.2f}%"
                    await self.trading_history.add_trade(ticker, "buy", executed_price, executed_amount, reason)

                    total_amount = position['amount'] + executed_amount
                    total_cost = (position['amount'] * position['entry_price']) + (executed_amount * executed_price)
                    new_avg_price = total_cost / total_amount if total_amount > 0 else executed_price
                    self.stop_loss_manager.update_position(ticker, new_avg_price=new_avg_price, amount=total_amount)

                    logger.info(f"{ticker} DCA ë§¤ìˆ˜ ì™„ë£Œ: ê°€ê²©={executed_price:,.2f}ì›, ìˆ˜ëŸ‰={executed_amount:.8f}ê°œ")
                    message = (
                        f"ğŸ’¡ í‰ë‹¨ í•˜í–¥ ë§¤ìˆ˜: {ticker}\n"
                        f"ê°€ê²©: {executed_price:,.2f}ì›\n"
                        f"ìˆ˜ëŸ‰: {executed_amount:.8f}ê°œ\n"
                        f"ì´ ê¸ˆì•¡: {executed_amount * executed_price:,.0f}ì›\n"
                        f"ì‚¬ìœ : {reason}"
                    )
                    await async_send_telegram_message(message)
                    return True
                else:
                    logger.error(f"{ticker} DCA ë§¤ìˆ˜ ë¯¸ì²´ê²°: {order_info}")
                    return False
            else:
                logger.error(f"{ticker} DCA ì£¼ë¬¸ ì‹¤íŒ¨: {buy_order or 'ì‘ë‹µ ì—†ìŒ'}")
                return False
        except Exception as e:
            logger.error(f"{ticker} DCA ì‹¤í–‰ ì‹¤íŒ¨: {e}")
            return False


async def execute_sell_strategy(self):
        """AI ê¸°ë°˜ ìë™ ë§¤ë„ ì „ëµ ì‹¤í–‰"""
        try:
            if not self.purchased_coins["coins"]:
                logger.info("ë³´ìœ  ì½”ì¸ ì—†ìŒ, ë§¤ë„ ì „ëµ ê±´ë„ˆëœ€")
                return

            market_analysis = self.market_analyzer.ai_analyze_market()
            if market_analysis is None:
                logger.info("ì‹œì¥ ë¶„ì„ ì‹¤íŒ¨, ë§¤ë„ ì „ëµ ì¤‘ë‹¨")
                return

            try:
                sell_ratio = float(market_analysis.get("sell_ratio", "0%").strip("%"))
                risk_level = int(market_analysis.get("risk_level", 5))
            except (ValueError, TypeError) as e:
                logger.error(f"ë§¤ë„ ë¹„ìœ¨ ë˜ëŠ” ìœ„í—˜ ìˆ˜ì¤€ í˜•ì‹ ì˜¤ë¥˜: {market_analysis}, ê¸°ë³¸ê°’ ì‚¬ìš©")
                sell_ratio = 0
                risk_level = 5

            for ticker in self.purchased_coins["coins"][:]:
                if not rate_limiter.can_make_api_call():
                    await asyncio.sleep(0.1)
                    continue

                try:
                    position = self.stop_loss_manager.positions.get(ticker)
                    if not position:
                        logger.warning(f"{ticker} í¬ì§€ì…˜ ì •ë³´ ì—†ìŒ")
                        continue

                    current_price = pyupbit.get_current_price(ticker)
                    if not current_price:
                        logger.error(f"{ticker} í˜„ì¬ ê°€ê²© ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨")
                        continue

                    entry_price = position["entry_price"]
                    amount = position["amount"]
                    profit_percent = ((current_price - entry_price) / entry_price) * 100
                    predicted_price = self.market_analyzer.predict_next_price(ticker)

                    sell_reason = []
                    should_sell = False

                    if profit_percent >= 10:
                        sell_reason.append(f"ìˆ˜ìµë¥  {profit_percent:.2f}% (ëª©í‘œ 10% ì´ˆê³¼)")
                        should_sell = True
                    elif profit_percent <= -5:
                        sell_reason.append(f"ì†ì‹¤ë¥  {profit_percent:.2f}% (ì†ì ˆ ê¸°ì¤€ -5% ì´ˆê³¼)")
                        should_sell = True

                    if risk_level >= 7:
                        sell_reason.append(f"ë†’ì€ ì‹œì¥ ìœ„í—˜ (ìœ„í—˜ ìˆ˜ì¤€ {risk_level})")
                        should_sell = True
                    if predicted_price and current_price and predicted_price < current_price * 0.95:
                        sell_reason.append(f"ì˜ˆì¸¡ ê°€ê²© í•˜ë½ ({predicted_price:,.2f}ì›, í˜„ì¬ê°€ ëŒ€ë¹„ -5% ì´ìƒ)")
                        should_sell = True
                    if sell_ratio >= 50:
                        sell_reason.append(f"AI ë§¤ë„ ë¹„ìœ¨ ê¶Œì¥ ({sell_ratio}%)")
                        should_sell = True

                    if not should_sell:
                        logger.info(f"{ticker} ë§¤ë„ ì¡°ê±´ ë¯¸ì¶©ì¡±: ìˆ˜ìµë¥ ={profit_percent:.2f}%, ì˜ˆì¸¡ê°€={predicted_price or 'ì—†ìŒ'}")
                        continue

                    try:
                        coin_data = {
                            "ticker": ticker,
                            "current_price": float(current_price),
                            "entry_price": float(entry_price),
                            "profit_percent": float(profit_percent),
                            "predicted_price": float(predicted_price) if predicted_price else None,
                            "market_risk_level": risk_level,
                            "sell_ratio": float(sell_ratio)
                        }
                        response = self.market_analyzer.client.chat.completions.create(
                            model="gpt-4",
                            messages=[
                                {
                                    "role": "system",
                                    "content": """ë‹¹ì‹ ì€ ì•”í˜¸í™”í ê±°ë˜ ì „ë¬¸ê°€ì…ë‹ˆë‹¤. ì£¼ì–´ì§„ ì½”ì¸ ë°ì´í„°ë¥¼ ë¶„ì„í•˜ì—¬ ë§¤ë„ ì‚¬ìœ ë¥¼ ê°„ê²°í•œ ë¬¸ìì—´ë¡œ ë°˜í™˜í•˜ì„¸ìš”. 
                                    ì˜ˆ: "ìˆ˜ìµë¥  10% ë‹¬ì„± ë° ì‹œì¥ í•˜ë½ ì˜ˆì¸¡". ë°˜ë“œì‹œ 50ì ì´ë‚´ë¡œ ìœ ì§€í•˜ì„¸ìš”."""
                                },
                                {
                                    "role": "user",
                                    "content": json.dumps(coin_data, default=serialize_numpy)
                                }
                            ]
                        )
                        reason = response.choices[0].message.content.strip()
                    except Exception as e:
                        logger.error(f"{ticker} ë§¤ë„ ì‚¬ìœ  ìƒì„± ì‹¤íŒ¨: {e}")
                        reason = ", ".join(sell_reason) or "AI ë§¤ë„ íŒë‹¨"

                    if not rate_limiter.can_make_order():
                        await asyncio.sleep(0.1)
                        continue

                    logger.info(f"{ticker} AI ë§¤ë„ ì‹œë„: ê°€ê²©={current_price:,.2f}ì›, ìˆ˜ëŸ‰={amount:.8f}ê°œ, ì‚¬ìœ ={reason}")
                    sell_order = upbit.sell_market_order(ticker, amount)

                    if sell_order and "uuid" in sell_order:
                        order_uuid = sell_order["uuid"]
                        order_info = upbit.get_order(order_uuid)
                        for _ in range(10):
                            if order_info and order_info["state"] in ["done", "cancel"]:
                                break
                            await asyncio.sleep(1)
                            order_info = upbit.get_order(order_uuid)

                        executed_amount = float(order_info.get("executed_volume", 0)) if order_info else 0
                        if executed_amount > 0:
                            executed_price = current_price
                            await self.trading_history.add_trade(ticker, "sell", executed_price, executed_amount, reason)
                            self.stop_loss_manager.remove_position(ticker)
                            if ticker in self.purchased_coins["coins"]:
                                self.purchased_coins["coins"].remove(ticker)
                                FileManager.save_json(COINS_FILE, self.purchased_coins)

                            logger.info(f"{ticker} AI ë§¤ë„ ì™„ë£Œ: ê°€ê²©={executed_price:,.2f}ì›, ìˆ˜ëŸ‰={executed_amount:.8f}ê°œ")
                            message = (
                                f"ğŸ”´ AI ë§¤ë„ ì‹¤í–‰: {ticker}\n"
                                f"ê°€ê²©: {executed_price:,.2f}ì›\n"
                                f"ìˆ˜ëŸ‰: {executed_amount:.8f}ê°œ\n"
                                f"ì´ ê¸ˆì•¡: {executed_amount * executed_price:,.0f}ì›\n"
                                f"ìˆ˜ìµë¥ : {profit_percent:.2f}%\n"
                                f"ì‚¬ìœ : {reason}"
                            )
                            await async_send_telegram_message(message)
                        else:
                            logger.error(f"{ticker} AI ë§¤ë„ ë¯¸ì²´ê²°: {order_info}")
                    else:
                        logger.error(f"{ticker} AI ë§¤ë„ ì£¼ë¬¸ ì‹¤íŒ¨: {sell_order or 'ì‘ë‹µ ì—†ìŒ'}")
                except Exception as e:
                    logger.error(f"{ticker} AI ë§¤ë„ ì „ëµ ì‹¤í–‰ ì‹¤íŒ¨: {e}")
        except Exception as e:
            logger.error(f"AI ë§¤ë„ ì „ëµ ì „ì²´ ì‹¤í–‰ ì‹¤íŒ¨: {e}", exc_info=True)

    async def check_pending_orders(self):
        try:
            for ticker, position in list(self.stop_loss_manager.positions.items()):
                if position.get('status') != 'pending' or 'order_uuid' not in position:
                    continue

                order_uuid = position['order_uuid']
                order_info = upbit.get_order(order_uuid)

                if not order_info:
                    logger.warning(f"{ticker} ì£¼ë¬¸ ì •ë³´ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨, UUID: {order_uuid}")
                    continue

                if order_info['state'] == 'done':
                    logger.info(f"{ticker} ì£¼ë¬¸ ì²´ê²°ë¨")

                    executed_amount = float(order_info['executed_volume'])
                    avg_price = float(order_info['price'])

                    reason = position.get('reason', 'AI ì¶”ì²œ')
                    await self.trading_history.add_trade(ticker, "buy", avg_price, executed_amount, reason)

                    position['status'] = 'active'
                    position['entry_price'] = avg_price
                    position['amount'] = executed_amount
                    self.stop_loss_manager.positions[ticker] = position
                    FileManager.save_json(POSITIONS_FILE, self.stop_loss_manager.positions)

                    if ticker not in self.purchased_coins["coins"]:
                        self.purchased_coins["coins"].append(ticker)
                        FileManager.save_json(COINS_FILE, self.purchased_coins)

                    take_profit_price = avg_price * 1.10
                    stop_loss_price = avg_price * 0.95

                    try:
                        tp_order = upbit.sell_limit_order(ticker, take_profit_price, executed_amount)
                        if tp_order and 'uuid' in tp_order:
                            position['take_profit_order_uuid'] = tp_order['uuid']
                            logger.info(f"{ticker} ìµì ˆ ì£¼ë¬¸ ì„¤ì •: {take_profit_price:,.2f}ì›")
                    except Exception as e:
                        logger.error(f"{ticker} ìµì ˆ ì£¼ë¬¸ ì„¤ì • ì‹¤íŒ¨: {e}")

                    position['stop_loss_price'] = stop_loss_price

                    self.stop_loss_manager.positions[ticker] = position
                    FileManager.save_json(POSITIONS_FILE, self.stop_loss_manager.positions)

                    message = (
                        f"âœ… ë§¤ìˆ˜ ì£¼ë¬¸ ì²´ê²°: {ticker}\n"
                        f"ì²´ê²°ê°€: {avg_price:,.2f}ì›\n"
                        f"ìˆ˜ëŸ‰: {executed_amount:.8f}ê°œ\n"
                        f"ì´ ê¸ˆì•¡: {executed_amount * avg_price:,.0f}ì›\n"
                        f"ìµì ˆê°€: {take_profit_price:,.2f}ì› (+10%)\n"
                        f"ì†ì ˆê°€: {stop_loss_price:,.2f}ì› (-5%)\n"
                    )
                    await async_send_telegram_message(message)

                elif order_info['state'] == 'wait':
                    logger.info(f"{ticker} ì£¼ë¬¸ ëŒ€ê¸° ì¤‘")
                elif order_info['state'] == 'cancel':
                    logger.info(f"{ticker} ì£¼ë¬¸ ì·¨ì†Œë¨")
                    del self.stop_loss_manager.positions[ticker]
                    FileManager.save_json(POSITIONS_FILE, self.stop_loss_manager.positions)
        except Exception as e:
            logger.error(f"ëŒ€ê¸° ì£¼ë¬¸ í™•ì¸ ì˜¤ë¥˜: {e}")
